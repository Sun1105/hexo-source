<div id="editorModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index: 1000;">
  <div style="background:#fff; width:90%; max-width:800px; margin:50px auto; padding:20px; border-radius:8px; position:relative; max-height: 90vh; overflow-y: auto;">
    <h2 id="editorTitle">ç¼–è¾‘æ–‡ç« </h2>

    <!-- æ ‡é¢˜è¾“å…¥æ¡† -->
    <input type="text" id="noteTitle" placeholder="æ ‡é¢˜" style="width:100%; padding:8px; margin-bottom:10px;">

    <!-- æ–‡ä»¶åè¾“å…¥æ¡† (æ–°å¢) -->
    <div style="margin-bottom: 10px; font-size: 0.85rem; color: #666; display: flex; align-items: center; gap: 10px;">
        <label for="noteFilename" style="white-space: nowrap;">æ–‡ä»¶è·¯å¾„:</label>
        <input type="text" id="noteFilename" placeholder="source/_posts/filename.md" style="flex: 1; padding: 5px; font-family: monospace; color: #555;">
    </div>

    <!-- åˆ†ç±»è¾“å…¥æ¡† -->
    <input type="text" id="noteCategory" placeholder="åˆ†ç±»" style="width:100%; padding:8px; margin-bottom:10px;">

    <!-- æ ‡ç­¾è¾“å…¥æ¡† -->
    <input type="text" id="noteTags" placeholder="æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš”" style="width:100%; padding:8px; margin-bottom:10px;">

    <!-- å†…å®¹è¾“å…¥æ¡† -->
    <textarea id="noteContent" rows="15" style="width:100%; padding:8px; font-family: monospace;"></textarea>

    <!-- ä¿å­˜/å–æ¶ˆæŒ‰é’® -->
    <div style="margin-top:10px; display:flex; gap:10px;">
      <button id="saveNoteBtn" style="flex:1; padding:10px; background:#28a745; color:#fff; border:none; border-radius:5px; cursor:pointer;">ğŸ’¾ ä¿å­˜</button>
      <button id="cancelEditBtn" style="flex:1; padding:10px; background:#dc3545; color:#fff; border:none; border-radius:5px; cursor:pointer;">âŒ å–æ¶ˆ</button>
    </div>

    <!-- Markdown å®æ—¶é¢„è§ˆ -->
    <div id="preview" style="margin-top:20px; padding:10px; border:1px solid #ddd; border-radius:5px; background: #f9f9f9;"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  window.mermaid = mermaid;
  mermaid.initialize({ startOnLoad: false });
</script>
<script>
(function() {
  const owner = "Sun1105";              // GitHub ç”¨æˆ·å
  const repo = "hexo-source";           // ä»“åº“å
  const postsDir = "source/_posts";     // æ–‡ç« ç›®å½•
  let editingNote = null;               // å½“å‰æ­£åœ¨ç¼–è¾‘çš„æ–‡ç« å¯¹è±¡

  const editorModal = document.getElementById('editorModal');
  const noteTitle = document.getElementById('noteTitle');
  const noteFilename = document.getElementById('noteFilename');
  const noteCategory = document.getElementById('noteCategory');
  const noteTags = document.getElementById('noteTags');
  const noteContent = document.getElementById('noteContent');
  const saveNoteBtn = document.getElementById('saveNoteBtn');
  const cancelEditBtn = document.getElementById('cancelEditBtn');
  const previewDiv = document.getElementById('preview');

  // æ¸²æŸ“é¢„è§ˆï¼ˆå« Mermaid æ”¯æŒï¼‰
  const renderPreview = async (content) => {
    const trimmed = content.trim();
    // æ£€æµ‹æ˜¯å¦ä¸ºå®Œæ•´ HTML æ–‡æ¡£
    const isFullHtml = trimmed.match(/^\s*<!DOCTYPE/i) || trimmed.match(/^\s*<html/i);

    if (isFullHtml) {
        // ä½¿ç”¨ iframe æ¸²æŸ“å®Œæ•´ HTML
        previewDiv.innerHTML = '<iframe id="previewFrame" style="width:100%; height:500px; border:1px solid #eee;"></iframe>';
        const frame = document.getElementById('previewFrame');
        if (frame) {
            const doc = frame.contentDocument || frame.contentWindow.document;
            doc.open();
            doc.write(content);
            doc.close();
        }
        return;
    }

    // Markdown æ¸²æŸ“
    previewDiv.innerHTML = marked.parse(content);

    if (window.mermaid) {
      const mermaidBlocks = previewDiv.querySelectorAll('code.language-mermaid');
      if (mermaidBlocks.length > 0) {
        mermaidBlocks.forEach(block => {
          const content = block.textContent;
          const pre = block.parentElement;
          const div = document.createElement('div');
          div.className = 'mermaid';
          div.textContent = content;
          if (pre && pre.parentNode) {
            pre.parentNode.replaceChild(div, pre);
          }
        });
        try {
          await window.mermaid.run({ querySelector: '#preview .mermaid' });
        } catch (e) {
          console.error("Mermaid render error:", e);
        }
      }
    }
  };

  // æš´éœ²ç»™å…¨å±€çš„å‡½æ•°
  window.openEditor = async function(pathOrFile) {
    let file;
    
    if (!pathOrFile) {
        // æ–°å»ºæ–‡ç« 
        file = null;
    } else if (typeof pathOrFile === 'string') {
        // å¦‚æœä¼ å…¥çš„æ˜¯å­—ç¬¦ä¸²ï¼ˆè·¯å¾„ï¼‰ï¼Œåˆ™è·å–æ–‡ä»¶ä¿¡æ¯
        let cleanPath = pathOrFile.replace(/\\/g, '/'); // ç¡®ä¿æ˜¯æ­£æ–œæ 
        if (!cleanPath.startsWith('source/')) {
            cleanPath = 'source/' + cleanPath;
        }
        
        // å¤„ç†ä¸­æ–‡è·¯å¾„
        const encodedPath = cleanPath.split('/').map(encodeURIComponent).join('/');

        try {
            console.log(`æ­£åœ¨è·å–æ–‡ä»¶ä¿¡æ¯: ${encodedPath}`);
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}`);
            if (!res.ok) {
                const errText = await res.text();
                throw new Error(`æ— æ³•è·å–æ–‡ä»¶ä¿¡æ¯ (Status: ${res.status}): ${errText}`);
            }
            file = await res.json();
        } catch (e) {
            console.error(e);
            alert('è·å–æ–‡ä»¶å¤±è´¥: ' + e.message + '\nè¯·æ£€æŸ¥æ§åˆ¶å° (F12) è·å–æ›´å¤šä¿¡æ¯ã€‚');
            return;
        }
    } else {
        file = pathOrFile;
    }

    editingNote = file;
    editorModal.style.display = "block";

    if (!file) {
        // æ–°å»ºæ¨¡å¼
        noteTitle.value = "";
        noteFilename.value = "source/_posts/" + Date.now() + ".md"; // é»˜è®¤æ–‡ä»¶å
        noteCategory.value = "";
        noteTags.value = "";
        noteContent.value = "";
        previewDiv.innerHTML = "";
        document.getElementById('editorTitle').innerText = "æ–°å»ºæ–‡ç« ";
        return;
    }

    // ç¼–è¾‘æ¨¡å¼
    document.getElementById('editorTitle').innerText = "ç¼–è¾‘æ–‡ç« ";
    noteTitle.value = "åŠ è½½ä¸­...";
    noteFilename.value = file.path || ""; // å¡«å……æ–‡ä»¶è·¯å¾„
    noteContent.value = "åŠ è½½ä¸­...";

    try {
      // è·å–æ–‡ä»¶å†…å®¹
      let content = "";
      if (file.content && file.encoding === 'base64') {
          // ä½¿ç”¨ TextDecoder å¤„ç† UTF-8 å­—ç¬¦ï¼Œæ¯” escape/decodeURIComponent æ›´ç°ä»£ä¸”ç¨³å¥
          try {
              const binaryString = window.atob(file.content.replace(/\n/g, ""));
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
              }
              content = new TextDecoder('utf-8').decode(bytes);
          } catch (e) {
              console.warn("TextDecoder failed, falling back to legacy decode:", e);
              content = decodeURIComponent(escape(window.atob(file.content.replace(/\n/g, ""))));
          }
      } else if (file.download_url) {
          // æ–‡ä»¶è¾ƒå¤§æ—¶ï¼ˆ>1MBï¼‰ï¼ŒAPI ä¸è¿”å› contentï¼Œéœ€ä» download_url è·å–
          console.log("File content too large, fetching from download_url...");
          const rawRes = await fetch(file.download_url);
          if (!rawRes.ok) {
              throw new Error(`æ— æ³•ä» download_url è·å–å†…å®¹: ${rawRes.status}`);
          }
          content = await rawRes.text();
      } else {
          // å…œåº•ï¼šå¦‚æœ API è¿”å›ç»“æ„ä¸ç¬¦åˆé¢„æœŸ
          if (file.content) {
             // é base64 ç¼–ç ï¼Ÿç›´æ¥ä½¿ç”¨
             content = file.content;
          } else {
             throw new Error("æœªæ‰¾åˆ°æ–‡ä»¶å†…å®¹ (No content field and no download_url)");
          }
      }

      // è§£æFront Matter
      // ä½¿ç”¨ js-yaml è§£æ
      const parts = content.split(/^---$/m);
      if (parts.length >= 3) {
        const frontMatterRaw = parts[1];
        const body = parts.slice(2).join('---').trim();
        
        try {
            const frontMatter = jsyaml.load(frontMatterRaw);
            
            // æ ‡é¢˜
            noteTitle.value = frontMatter.title || "";
            
            // åˆ†ç±»
            if (frontMatter.categories) {
                if (Array.isArray(frontMatter.categories)) {
                    // å¦‚æœæ˜¯æ•°ç»„ï¼Œå±•å¹³å¹¶ç”¨é€—å·åˆ†éš”
                    noteCategory.value = frontMatter.categories.flat().join(", ");
                } else {
                    noteCategory.value = frontMatter.categories;
                }
            } else if (frontMatter.category) {
                 // å…¼å®¹ category å­—æ®µ
                 if (Array.isArray(frontMatter.category)) {
                    noteCategory.value = frontMatter.category.flat().join(", ");
                } else {
                    noteCategory.value = frontMatter.category;
                }
            } else {
                noteCategory.value = "";
            }

            // æ ‡ç­¾
            if (frontMatter.tags) {
                if (Array.isArray(frontMatter.tags)) {
                    noteTags.value = frontMatter.tags.flat().join(", ");
                } else {
                    noteTags.value = frontMatter.tags;
                }
            } else {
                noteTags.value = "";
            }

        } catch (e) {
            console.error("YAML parsing error:", e);
            alert("YAML è§£æå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥ Front Matter æ ¼å¼");
        }

        noteContent.value = body;
        renderPreview(body);

      } else {
        // æ²¡æœ‰Front Matter
        noteTitle.value = file.name.replace(/\.md$/, '');
        noteContent.value = content;
        renderPreview(content);
      }

    } catch (e) {
      console.error(e);
      noteContent.value = "è¯»å–å†…å®¹å¤±è´¥: " + e.message;
    }
  };

  // ç›‘å¬è¾“å…¥ï¼Œå®æ—¶é¢„è§ˆ
  noteContent.addEventListener('input', () => {
    renderPreview(noteContent.value);
  });

  // å…³é—­
  cancelEditBtn.onclick = () => {
    editorModal.style.display = "none";
    editingNote = null;
  };

  // ç‚¹å‡»å¤–éƒ¨å…³é—­
  window.onclick = (event) => {
    if (event.target == editorModal) {
      editorModal.style.display = "none";
      editingNote = null;
    }
  };

  // ä¿å­˜
  saveNoteBtn.onclick = async () => {
    const title = noteTitle.value.trim();
    const content = noteContent.value;
    const categories = noteCategory.value.trim();
    const tags = noteTags.value.trim();
    let filepath = noteFilename.value.trim();

    if (!title) {
      alert("è¯·è¾“å…¥æ ‡é¢˜");
      return;
    }
    
    if (!filepath) {
        alert("è¯·è¾“å…¥æ–‡ä»¶è·¯å¾„");
        return;
    }
    
    // ç¡®ä¿è·¯å¾„ä»¥ source/ å¼€å¤´ (å¯é€‰ï¼Œè§†éœ€æ±‚è€Œå®šï¼ŒHexoé€šå¸¸åœ¨sourceä¸‹)
    if (!filepath.startsWith('source/')) {
        filepath = 'source/' + filepath;
    }
    // ç¡®ä¿ä»¥ .md ç»“å°¾
    if (!filepath.endsWith('.md')) {
        filepath += '.md';
    }

    // æ„é€ æ–°çš„æ–‡ä»¶å†…å®¹ï¼ˆå« Front Matterï¼‰
    let newFileContent = "---\n";
    newFileContent += `title: ${title}\n`;
    newFileContent += `date: ${new Date().toISOString()}\n`;
    if (categories) newFileContent += `categories: [${categories}]\n`;
    if (tags) newFileContent += `tags: [${tags}]\n`;
    newFileContent += "---\n\n";
    newFileContent += content;

    // Base64 ç¼–ç 
    // const contentBase64 = window.btoa(unescape(encodeURIComponent(newFileContent)));
    // API æœŸæœ›ç›´æ¥çš„å­—ç¬¦ä¸²ï¼Œå®ƒä¼šåœ¨åç«¯è¿›è¡Œ Base64 ç¼–ç 
    
    const sha = editingNote ? editingNote.sha : null;
    // const path = editingNote ? editingNote.path : `source/_posts/${Date.now()}-${title}.md`;
    
    // ä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„æ–‡ä»¶è·¯å¾„
    // æ³¨æ„ï¼šå¦‚æœæ˜¯é‡å‘½åï¼ˆä¿®æ”¹äº†è·¯å¾„ï¼‰ï¼Œsha åº”è¯¥ä¸º nullï¼ˆè§†ä¸ºæ–°æ–‡ä»¶ï¼‰ï¼Œæˆ–è€…åç«¯æ”¯æŒç§»åŠ¨æ“ä½œ
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šå¦‚æœè·¯å¾„å˜äº†ï¼Œå°±è§†ä¸ºåˆ›å»ºæ–°æ–‡ä»¶ã€‚æ—§æ–‡ä»¶ä¾ç„¶å­˜åœ¨ï¼ˆé™¤éåç«¯æœ‰å¤„ç†é€»è¾‘ï¼‰ã€‚
    // çœŸæ­£çš„é‡å‘½åéœ€è¦ delete old + create new
    
    const isRename = editingNote && (editingNote.path !== filepath);
    const finalSha = isRename ? null : sha; 
    
    const payload = {
        path: filepath,
        message: sha ? `Update ${title}` : `Create ${title}`,
        content: newFileContent, // ç›´æ¥å‘é€å†…å®¹ï¼Œåç«¯å¤„ç† Base64
        sha: finalSha
    };

    // å†³å®šè°ƒç”¨å“ªä¸ªåç«¯ API (æœ¬åœ°ä»£ç†)
    // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬è°ƒç”¨æœ¬åœ°çš„ Serverless Function æˆ–è€… Next.js API è·¯ç”±
    // å¦‚æœæ˜¯çº¯ Hexo é™æ€ç«™ï¼Œé€šå¸¸æ²¡æœ‰åç«¯ã€‚
    // ä½†ç”¨æˆ·ä¹‹å‰çš„ new-note.js æš—ç¤ºäº†æœ‰ Vercel API æ”¯æŒã€‚
    // æˆ‘ä»¬éœ€è¦ç¡®è®¤ API è·¯å¾„ã€‚æ ¹æ®ä¹‹å‰çš„åˆ†æï¼ŒAPI åœ¨ api/ ç›®å½•ä¸‹ã€‚
    // Vercel ä¼šå°† api/ ç›®å½•ä¸‹çš„æ–‡ä»¶éƒ¨ç½²ä¸º Serverless Functionsã€‚
    // å‡è®¾è·¯å¾„æ˜¯ /api/new-note å’Œ /api/edit-note

    const apiUrl = sha ? '/api/edit-note' : '/api/new-note';

    saveNoteBtn.disabled = true;
    saveNoteBtn.innerText = "ä¿å­˜ä¸­...";

    try {
        const res = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        const data = await res.json();
        
        if (res.ok) {
            alert("ä¿å­˜æˆåŠŸï¼å³å°†åˆ·æ–°...");
            location.reload();
        } else {
            alert("ä¿å­˜å¤±è´¥: " + (data.error || JSON.stringify(data)));
        }
    } catch (e) {
        console.error(e);
        alert("è¯·æ±‚å¤±è´¥: " + e.message);
    } finally {
        saveNoteBtn.disabled = false;
        saveNoteBtn.innerText = "ğŸ’¾ ä¿å­˜";
    }
  };
})();
</script>