<div id="editorModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index: 1000;">
  <div style="background:#fff; width:90%; max-width:800px; margin:50px auto; padding:20px; border-radius:8px; position:relative; max-height: 90vh; overflow-y: auto;">
    <h2 id="editorTitle">ç¼–è¾‘æ–‡ç« </h2>

    <!-- æ ‡é¢˜è¾“å…¥æ¡† -->
    <input type="text" id="noteTitle" placeholder="æ ‡é¢˜" style="width:100%; padding:8px; margin-bottom:10px;">

    <!-- åˆ†ç±»è¾“å…¥æ¡† -->
    <input type="text" id="noteCategory" placeholder="åˆ†ç±»" style="width:100%; padding:8px; margin-bottom:10px;">

    <!-- æ ‡ç­¾è¾“å…¥æ¡† -->
    <input type="text" id="noteTags" placeholder="æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš”" style="width:100%; padding:8px; margin-bottom:10px;">

    <!-- å†…å®¹è¾“å…¥æ¡† -->
    <textarea id="noteContent" rows="15" style="width:100%; padding:8px; font-family: monospace;"></textarea>

    <!-- ä¿å­˜/å–æ¶ˆæŒ‰é’® -->
    <div style="margin-top:10px; display:flex; gap:10px;">
      <button id="saveNoteBtn" style="flex:1; padding:10px; background:#28a745; color:#fff; border:none; border-radius:5px; cursor:pointer;">ğŸ’¾ ä¿å­˜</button>
      <button id="cancelEditBtn" style="flex:1; padding:10px; background:#dc3545; color:#fff; border:none; border-radius:5px; cursor:pointer;">âŒ å–æ¶ˆ</button>
    </div>

    <!-- Markdown å®æ—¶é¢„è§ˆ -->
    <div id="preview" style="margin-top:20px; padding:10px; border:1px solid #ddd; border-radius:5px; background: #f9f9f9;"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
<script>
(function() {
  const owner = "Sun1105";              // GitHub ç”¨æˆ·å
  const repo = "hexo-source";           // ä»“åº“å
  const postsDir = "source/_posts";     // æ–‡ç« ç›®å½•
  let editingNote = null;               // å½“å‰æ­£åœ¨ç¼–è¾‘çš„æ–‡ç« å¯¹è±¡

  const editorModal = document.getElementById('editorModal');
  const noteTitle = document.getElementById('noteTitle');
  const noteCategory = document.getElementById('noteCategory');
  const noteTags = document.getElementById('noteTags');
  const noteContent = document.getElementById('noteContent');
  const saveNoteBtn = document.getElementById('saveNoteBtn');
  const cancelEditBtn = document.getElementById('cancelEditBtn');
  const previewDiv = document.getElementById('preview');

  // æš´éœ²ç»™å…¨å±€çš„å‡½æ•°
  window.openEditor = async function(pathOrFile) {
    let file;
    
    if (!pathOrFile) {
        // æ–°å»ºæ–‡ç« 
        file = null;
    } else if (typeof pathOrFile === 'string') {
        // å¦‚æœä¼ å…¥çš„æ˜¯å­—ç¬¦ä¸²ï¼ˆè·¯å¾„ï¼‰ï¼Œåˆ™è·å–æ–‡ä»¶ä¿¡æ¯
        let cleanPath = pathOrFile.replace(/\\/g, '/'); // ç¡®ä¿æ˜¯æ­£æ–œæ 
        if (!cleanPath.startsWith('source/')) {
            cleanPath = 'source/' + cleanPath;
        }
        
        // å¤„ç†ä¸­æ–‡è·¯å¾„
        const encodedPath = cleanPath.split('/').map(encodeURIComponent).join('/');

        try {
            console.log(`æ­£åœ¨è·å–æ–‡ä»¶ä¿¡æ¯: ${encodedPath}`);
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}`);
            if (!res.ok) {
                const errText = await res.text();
                throw new Error(`æ— æ³•è·å–æ–‡ä»¶ä¿¡æ¯ (Status: ${res.status}): ${errText}`);
            }
            file = await res.json();
        } catch (e) {
            console.error(e);
            alert('è·å–æ–‡ä»¶å¤±è´¥: ' + e.message + '\nè¯·æ£€æŸ¥æ§åˆ¶å° (F12) è·å–æ›´å¤šä¿¡æ¯ã€‚');
            return;
        }
    } else {
        file = pathOrFile;
    }

    editingNote = file;
    editorModal.style.display = "block";

    if (!file) {
        // æ–°å»ºæ¨¡å¼
        noteTitle.value = "";
        noteCategory.value = "";
        noteTags.value = "";
        noteContent.value = "";
        previewDiv.innerHTML = "";
        document.getElementById('editorTitle').innerText = "æ–°å»ºæ–‡ç« ";
        return;
    }

    // ç¼–è¾‘æ¨¡å¼
    document.getElementById('editorTitle').innerText = "ç¼–è¾‘æ–‡ç« ";
    noteTitle.value = "åŠ è½½ä¸­...";
    noteContent.value = "åŠ è½½ä¸­...";

    try {
      // è·å–æ–‡ä»¶å†…å®¹
      // å¦‚æœæ²¡æœ‰contentå±æ€§ï¼Œå¯èƒ½éœ€è¦å†æ¬¡è·å–blob? é€šå¸¸contents APIè¿”å›content
      let content = "";
      if (file.content) {
        // GitHub API returns base64 content with newlines
        content = decodeURIComponent(escape(window.atob(file.content.replace(/\n/g, ""))));
      } else {
        // å°è¯•é€šè¿‡download_urlè·å–? 
        // ç®€åŒ–èµ·è§ï¼Œå‡è®¾contentå­˜åœ¨
      }

      // è§£æFront Matter
      // ä½¿ç”¨ js-yaml è§£æ
      const parts = content.split(/^---$/m);
      if (parts.length >= 3) {
        const frontMatterRaw = parts[1];
        const body = parts.slice(2).join('---').trim();
        
        try {
            const frontMatter = jsyaml.load(frontMatterRaw);
            
            // æ ‡é¢˜
            noteTitle.value = frontMatter.title || "";
            
            // åˆ†ç±»
            if (frontMatter.categories) {
                if (Array.isArray(frontMatter.categories)) {
                    // å¦‚æœæ˜¯æ•°ç»„ï¼Œå±•å¹³å¹¶ç”¨é€—å·åˆ†éš”
                    noteCategory.value = frontMatter.categories.flat().join(", ");
                } else {
                    noteCategory.value = frontMatter.categories;
                }
            } else if (frontMatter.category) {
                 // å…¼å®¹ category å­—æ®µ
                 if (Array.isArray(frontMatter.category)) {
                    noteCategory.value = frontMatter.category.flat().join(", ");
                } else {
                    noteCategory.value = frontMatter.category;
                }
            } else {
                noteCategory.value = "";
            }

            // æ ‡ç­¾
            if (frontMatter.tags) {
                if (Array.isArray(frontMatter.tags)) {
                    noteTags.value = frontMatter.tags.flat().join(", ");
                } else {
                    noteTags.value = frontMatter.tags;
                }
            } else {
                noteTags.value = "";
            }

        } catch (e) {
            console.error("YAML parsing error:", e);
            alert("YAML è§£æå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥ Front Matter æ ¼å¼");
        }

        noteContent.value = body;
        previewDiv.innerHTML = marked.parse(body);

      } else {
        // æ²¡æœ‰Front Matter
        noteTitle.value = file.name.replace(/\.md$/, '');
        noteContent.value = content;
        previewDiv.innerHTML = marked.parse(content);
      }

    } catch (e) {
      console.error(e);
      noteContent.value = "è¯»å–å†…å®¹å¤±è´¥: " + e.message;
    }
  };

  // ç›‘å¬è¾“å…¥ï¼Œå®æ—¶é¢„è§ˆ
  noteContent.addEventListener('input', () => {
    previewDiv.innerHTML = marked.parse(noteContent.value);
  });

  // å…³é—­
  cancelEditBtn.onclick = () => {
    editorModal.style.display = "none";
    editingNote = null;
  };

  // ç‚¹å‡»å¤–éƒ¨å…³é—­
  window.onclick = (event) => {
    if (event.target == editorModal) {
      editorModal.style.display = "none";
      editingNote = null;
    }
  };

  // ä¿å­˜
  saveNoteBtn.onclick = async () => {
    const title = noteTitle.value.trim();
    const content = noteContent.value;
    const categories = noteCategory.value.trim();
    const tags = noteTags.value.trim();

    if (!title) {
      alert("è¯·è¾“å…¥æ ‡é¢˜");
      return;
    }

    // æ„é€ æ–°çš„æ–‡ä»¶å†…å®¹ï¼ˆå« Front Matterï¼‰
    let newFileContent = "---\n";
    newFileContent += `title: ${title}\n`;
    newFileContent += `date: ${new Date().toISOString()}\n`;
    if (categories) newFileContent += `categories: [${categories}]\n`;
    if (tags) newFileContent += `tags: [${tags}]\n`;
    newFileContent += "---\n\n";
    newFileContent += content;

    // Base64 ç¼–ç 
    // const contentBase64 = window.btoa(unescape(encodeURIComponent(newFileContent)));
    // API æœŸæœ›ç›´æ¥çš„å­—ç¬¦ä¸²ï¼Œå®ƒä¼šåœ¨åç«¯è¿›è¡Œ Base64 ç¼–ç 
    
    const sha = editingNote ? editingNote.sha : null;
    const path = editingNote ? editingNote.path : `source/_posts/${Date.now()}-${title}.md`;

    const payload = {
        path: path,
        message: sha ? `Update ${title}` : `Create ${title}`,
        content: newFileContent, // ç›´æ¥å‘é€å†…å®¹ï¼Œåç«¯å¤„ç† Base64
        sha: sha
    };

    // å†³å®šè°ƒç”¨å“ªä¸ªåç«¯ API (æœ¬åœ°ä»£ç†)
    // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬è°ƒç”¨æœ¬åœ°çš„ Serverless Function æˆ–è€… Next.js API è·¯ç”±
    // å¦‚æœæ˜¯çº¯ Hexo é™æ€ç«™ï¼Œé€šå¸¸æ²¡æœ‰åç«¯ã€‚
    // ä½†ç”¨æˆ·ä¹‹å‰çš„ new-note.js æš—ç¤ºäº†æœ‰ Vercel API æ”¯æŒã€‚
    // æˆ‘ä»¬éœ€è¦ç¡®è®¤ API è·¯å¾„ã€‚æ ¹æ®ä¹‹å‰çš„åˆ†æï¼ŒAPI åœ¨ api/ ç›®å½•ä¸‹ã€‚
    // Vercel ä¼šå°† api/ ç›®å½•ä¸‹çš„æ–‡ä»¶éƒ¨ç½²ä¸º Serverless Functionsã€‚
    // å‡è®¾è·¯å¾„æ˜¯ /api/new-note å’Œ /api/edit-note

    const apiUrl = sha ? '/api/edit-note' : '/api/new-note';

    saveNoteBtn.disabled = true;
    saveNoteBtn.innerText = "ä¿å­˜ä¸­...";

    try {
        const res = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        const data = await res.json();
        
        if (res.ok) {
            alert("ä¿å­˜æˆåŠŸï¼å³å°†åˆ·æ–°...");
            location.reload();
        } else {
            alert("ä¿å­˜å¤±è´¥: " + (data.error || JSON.stringify(data)));
        }
    } catch (e) {
        console.error(e);
        alert("è¯·æ±‚å¤±è´¥: " + e.message);
    } finally {
        saveNoteBtn.disabled = false;
        saveNoteBtn.innerText = "ğŸ’¾ ä¿å­˜";
    }
  };
})();
</script>